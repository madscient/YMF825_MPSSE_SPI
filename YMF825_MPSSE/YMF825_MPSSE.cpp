// YMF825_MPSSE.cpp : コンソール アプリケーションのエントリ ポイントを定義します。
//

#include "stdafx.h"

/******************************************************************************/
/* 							 Include files										   */
/******************************************************************************/
/* Standard C libraries */
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include "FTSPI.h"

CFTSPI* pInterface;
const int chidx = 0;		// Interface ID

#define CS_LEFT		0xf0
#define CS_RIGHT	0xe8
#define CS_BOTH		0xe0

void reset()
{
	pInterface->FT_WriteGPIO(chidx, 0xff, 0xff);
	::Sleep(2);
	pInterface->FT_WriteGPIO(chidx, 0xff, 0x00);
	::Sleep(2);
	pInterface->FT_WriteGPIO(chidx, 0xff, 0xff);
	pInterface->SPI_Flush();
}

void write_reg(uint8 addr, uint8 data, uint8 csmask)
{
	UINT32 sizeToTransfer = 0;
	UINT32 sizeTransfered = 0;
	FT_STATUS status;
	BYTE buf[2];

	buf[0] = BYTE(addr);
	buf[1] = BYTE(data);
	sizeToTransfer = 2;
	sizeTransfered = 0;
	status = pInterface->SPI_Write(chidx, buf, sizeToTransfer, csmask);
	//pInterface->SPI_Flush(chidx);
}

void write_burst(BYTE* buf, size_t length, uint8 csmask)
{
	FT_STATUS status = pInterface->SPI_Write(chidx, buf, length, csmask);
	//pInterface->SPI_Flush(chidx);
	assert(status == FT_OK);
}

void write_burst(uint8 addr, uint8* data, uint32 size, uint8 csmask)
{
	BYTE* newbuf = new BYTE[size + 1];
	newbuf[0] = BYTE(addr);
	memcpy(&newbuf[1], data, size);
	write_burst(newbuf, size + 1, csmask);
	delete[] newbuf;
}

#define OUTPUT_power 1

uint16 freqtable[] = {
	//c  c+   d    d+   e    f    f+   g    g+   a    a+   b
	357, 378, 401, 425, 450, 477, 505, 535, 567, 601, 637, 674,
};

void init825()
{
	write_reg(0x1D, OUTPUT_power, CS_BOTH);
	write_reg(0x02, 0x0f, CS_BOTH);
	pInterface->SPI_Flush();
	::Sleep(1);
	write_reg(0x00, 0x01, CS_BOTH);//CLKEN
	write_reg(0x01, 0x00, CS_BOTH); //AKRST
	write_reg(0x1A, 0xA3, CS_BOTH);
	pInterface->SPI_Flush();
	::Sleep(1);
	write_reg(0x1A, 0x00, CS_BOTH);
	pInterface->SPI_Flush();
	::Sleep(30);
	write_reg(0x02, 0x00, CS_BOTH);
	//add
	write_reg(0x19, 0x33<<2, CS_BOTH);//MASTER VOL
	write_reg(0x1B, 0x3F, CS_BOTH);//interpolation
	write_reg(0x14, 0x00, CS_BOTH);//interpolation
	write_reg(0x03, 0x01, CS_BOTH);//Analog Gain

	write_reg(0x08, 0xF6, CS_BOTH);
	pInterface->SPI_Flush();
	::Sleep(21);
	write_reg(0x08, 0x00, CS_BOTH);
	write_reg(0x09, 0xF8, CS_BOTH);
	write_reg(0x0A, 0x00, CS_BOTH);

	write_reg(0x17, 0x40, CS_BOTH);//MS_S
	write_reg(0x18, 0x00, CS_BOTH);

	pInterface->SPI_Flush();
}

unsigned char tone_data0[35] = {
	0x81,//header
		 //T_ADR 0
		 0x01,0x85,
		 0x00,0x7F,0xF4,0xBB,0x00,0x10,0x40,
		 0x00,0xAF,0xA0,0x0E,0x03,0x10,0x40,
		 0x00,0x2F,0xF3,0x9B,0x00,0x20,0x41,
		 0x00,0xAF,0xA0,0x0E,0x01,0x10,0x40,
		 0x80,0x03,0x81,0x80,
};

unsigned char tone_data1[] = {
	0x90 //header
	 //Tone No.0
	,0x01, 0x43
	, 0x00, 0x67, 0xFF, 0x25, 0x00, 0x10, 0x40
	, 0x21, 0x33, 0xE2, 0x1F, 0x00, 0x50, 0x00
	, 0x10, 0x41, 0xD3, 0x14, 0x02, 0x10, 0x00
	, 0x21, 0x63, 0xD4, 0x02, 0x02, 0x10, 0x00
	//Tone No.1
	,0x01, 0x43
	, 0x21, 0x22, 0xF5, 0x26, 0x00, 0x10, 0x00
	, 0x20, 0x32, 0xFF, 0x1E, 0x00, 0x50, 0x00
	, 0x21, 0x22, 0xFD, 0x1A, 0x02, 0x10, 0x00
	, 0x11, 0x52, 0xF4, 0x08, 0x02, 0x10, 0x00
	//Tone No.2
	,0x01, 0x45
	, 0x21, 0x42, 0xD6, 0x15, 0x00, 0x40, 0x06
	, 0x11, 0x61, 0xD7, 0x0A, 0x02, 0x10, 0x00
	, 0x31, 0x43, 0xDE, 0x09, 0x00, 0x20, 0x00
	, 0x11, 0x51, 0xDF, 0x0A, 0x02, 0x20, 0x00
	//Tone No.3
	,0x01, 0x45
	, 0x21, 0x51, 0xFE, 0x18, 0x13, 0x10, 0x06
	, 0x21, 0xA3, 0xD3, 0x02, 0x16, 0x20, 0x00
	, 0x20, 0x51, 0xC3, 0x14, 0x20, 0x10, 0x05
	, 0x31, 0xA3, 0xD3, 0x02, 0x11, 0x20, 0x00
	//Tone No.4
	,0x01, 0x83
	, 0x21, 0xA3, 0xB3, 0x19, 0x60, 0x30, 0x01
	, 0x20, 0x92, 0xB4, 0x1B, 0x01, 0x30, 0x00
	, 0x11, 0x44, 0xA1, 0x11, 0x01, 0x20, 0x01
	, 0x11, 0x71, 0xA8, 0x04, 0x62, 0x10, 0x00
	//Tone No.5
	,0x01, 0x45
	, 0x51, 0xC4, 0xFB, 0x20, 0x11, 0x70, 0x95
	, 0x10, 0x82, 0xFF, 0x06, 0x12, 0x10, 0x00
	, 0x11, 0xB0, 0xF1, 0x11, 0x11, 0x10, 0x02
	, 0x11, 0x72, 0xFF, 0x04, 0x12, 0x10, 0x00
	//Tone No.6
	,0x01, 0x46
	, 0x21, 0x52, 0xE0, 0x01, 0x00, 0x10, 0x24
	, 0x01, 0x52, 0xF3, 0x17, 0x00, 0x60, 0x18
	, 0x01, 0x13, 0xF6, 0x1E, 0x00, 0x70, 0x20
	, 0x21, 0x72, 0xEF, 0x04, 0x06, 0x10, 0x28
	//Tone No.7
	,0x01, 0x43
	, 0x10, 0x61, 0xFF, 0x18, 0x11, 0x10, 0x2D
	, 0x10, 0x51, 0xF0, 0x1C, 0x11, 0x10, 0x00
	, 0x31, 0x73, 0xF2, 0x19, 0x11, 0x70, 0x20
	, 0x21, 0x92, 0xF2, 0x08, 0x12, 0x30, 0x00
	//Tone No.8
	,0x01, 0x45
	, 0x61, 0x56, 0xEF, 0x16, 0x00, 0x90, 0x12
	, 0x40, 0x44, 0xDE, 0x04, 0x02, 0x10, 0x00
	, 0x61, 0x66, 0xEC, 0x17, 0x00, 0xB0, 0x28
	, 0x40, 0x44, 0xEE, 0x04, 0x02, 0x10, 0x00
	//Tone No.9
	,0x01, 0x47
	, 0x31, 0x49, 0xF4, 0x08, 0x11, 0x70, 0x00
	, 0x21, 0x3B, 0xFB, 0x0C, 0x11, 0x40, 0x00
	, 0x21, 0x43, 0xF4, 0x11, 0x11, 0x20, 0x01
	, 0x30, 0x44, 0xFE, 0x04, 0x11, 0x10, 0x00
	//Tone No.10
	,0x01, 0x45
	, 0x21, 0x25, 0x50, 0x22, 0x00, 0x20, 0x08
	, 0x31, 0x24, 0xF0, 0x01, 0x02, 0x10, 0x00
	, 0x21, 0x25, 0xA0, 0x1C, 0x00, 0x90, 0x08
	, 0x11, 0x12, 0xF0, 0x04, 0x02, 0x10, 0x00
	//Tone No.11
	,0x01, 0x45
	, 0x20, 0x44, 0xC2, 0x14, 0x12, 0x70, 0x00
	, 0x21, 0x59, 0xD6, 0x06, 0x32, 0x40, 0x00
	, 0x21, 0x34, 0xC2, 0x1C, 0x32, 0x80, 0x00
	, 0x30, 0x42, 0xDF, 0x04, 0x62, 0x10, 0x00
	//Tone No.12
	,0x01, 0x45
	, 0x41, 0x47, 0xAF, 0x29, 0x00, 0xC0, 0x07
	, 0x40, 0x54, 0xBF, 0x04, 0x02, 0x10, 0x00
	, 0x61, 0x47, 0xBF, 0x20, 0x00, 0x60, 0x00
	, 0x51, 0x54, 0xDF, 0x04, 0x02, 0x10, 0x00
	//Tone No.13
	,0x01, 0x45
	, 0x60, 0x69, 0xFD, 0x1A, 0x00, 0x50, 0x02
	, 0x50, 0x77, 0xFD, 0x00, 0x06, 0x10, 0x00
	, 0x61, 0x66, 0xFA, 0x1E, 0x00, 0x50, 0x00
	, 0x60, 0x76, 0xFE, 0x02, 0x06, 0x10, 0x00
	//Tone No.14
	,0x01, 0x45
	, 0x30, 0x34, 0xF5, 0x11, 0x60, 0xA0, 0x80
	, 0x20, 0x33, 0xF2, 0x04, 0x06, 0x10, 0x00
	, 0x30, 0x34, 0xF5, 0x11, 0x60, 0x70, 0x47
	, 0x20, 0x33, 0xF2, 0x06, 0x06, 0x20, 0x00
	//Tone No.15
	,0x01, 0x46
	, 0x40, 0x4A, 0xEC, 0x06, 0x00, 0x20, 0x0B
	, 0x30, 0x33, 0xB5, 0x15, 0x00, 0x30, 0x08
	, 0x30, 0x33, 0xD0, 0x08, 0x00, 0x10, 0x00
	, 0x40, 0x44, 0xC6, 0x04, 0x06, 0x10, 0x00
	,0x80,0x03,0x81,0x80,
};

void set_tone(byte* tone_data, size_t len) {

	//write_reg(0x08, 0xF6, CS_BOTH);
	//pInterface->SPI_Flush();
	//::Sleep(1);
	//write_reg(0x08, 0x00, CS_BOTH);

	write_burst(0x07, tone_data, len, CS_BOTH);//write to FIFO
	pInterface->SPI_Flush();
}

void set_volume(uint8 ch, uint8 chvol, uint8 panpot)
{
	int pan = int(panpot) - 1;
	pan = (pan < 0) ? 0 : pan;
	double lgain = cos(M_PI_2 * pan / 126.0);
	double rgain = sin(M_PI_2 * pan / 126.0);
	write_reg(0x0B, ch, CS_BOTH);//voice num
	write_reg(0x10, (uint8)round(double(chvol) * lgain), CS_LEFT);// chvol
	write_reg(0x10, (uint8)round(double(chvol) * rgain), CS_RIGHT);// chvol
	pInterface->SPI_Flush();
}

void set_ch(uint8 ch) {
	write_reg(0x0B, ch, CS_BOTH);//voice num
	write_reg(0x0F, 0x30, CS_BOTH);// keyon = 0
	//write_reg(0x10, 0x7d, CS_BOTH);// chvol
	write_reg(0x11, 0x00, CS_BOTH);// XVB
	write_reg(0x12, 0x08, CS_BOTH);// FRAC
	write_reg(0x13, 0x00, CS_BOTH);// FRAC  
	pInterface->SPI_Flush();
}

void keyon(uint8 ch, uint8 blk, uint16 fnum) {
	uint8 fnumh = ((fnum >> 4) & 0x38) | (blk & 7);
	uint8 fnuml = (fnum) & 0x7f;
	write_reg(0x0B, ch, CS_BOTH);//voice num
	write_reg(0x0C, 0x7c, CS_BOTH);//vovol
	write_reg(0x0D, fnumh, CS_BOTH);//fnum
	write_reg(0x0E, fnuml, CS_BOTH);//fnum
	write_reg(0x0F, 0x44, CS_BOTH);//keyon = 1  
	pInterface->SPI_Flush();
}

void keyoff(uint8 ch) {
	write_reg(0x0B, ch, CS_BOTH);//voice num
	write_reg(0x0F, 0x04, CS_BOTH);//keyon = 0
	pInterface->SPI_Flush();
}

#define BEATTIME	333


enum E_KEYCODES {
	KEY_C, KEY_Cs, KEY_D, KEY_Ds, KEY_E, KEY_F, KEY_Fs, KEY_G, KEY_Gs, KEY_A, KEYAs, KEY_B,
};
struct SEQ {
	uint8 oct;
	uint8 keycode;
	uint16 duration;
};


SEQ daisybell[] = {
	{ 5, KEY_D, 3, }, { 4, KEY_B, 3, },	{ 4, KEY_G, 3, }, { 4, KEY_D, 3, },
	{ 4, KEY_E, 1, }, { 4, KEY_Fs, 1, }, { 4, KEY_G, 1, }, { 4, KEY_E, 2, }, { 4, KEY_G, 1, },
	{ 4, KEY_D, 6, },

	{ 4, KEY_A, 3, }, { 5, KEY_D, 3, }, { 4, KEY_B, 3, }, { 4, KEY_G, 3, },
	{ 4, KEY_E, 1, }, { 4, KEY_Fs, 1, }, { 4, KEY_G, 1, }, { 4, KEY_A, 2, }, { 4, KEY_B, 1, },
	{ 4, KEY_A, 5, }, { 4, KEY_B, 1, },

	{ 5, KEY_C, 1, }, { 4, KEY_B, 1, }, { 4, KEY_A, 1, }, { 5, KEY_D, 2, }, { 4, KEY_B, 1, },
	{ 4, KEY_A, 1, }, { 4, KEY_G, 4, }, { 4, KEY_A, 1, },
	{ 4, KEY_B, 2, }, { 4, KEY_G, 1, }, { 4, KEY_E, 2, }, { 4, KEY_G, 1, }, { 4, KEY_E, 1, }, { 4, KEY_D, 4, }, { 4, KEY_D, 1, },
	{ 4, KEY_G, 2, }, { 4, KEY_B, 1, }, { 4, KEY_A, 2, }, { 4, KEY_D, 1, },	{ 4, KEY_G, 2, }, { 4, KEY_B, 1, }, { 4, KEY_A, 1, }, { 4, KEY_B, 1, }, { 5, KEY_C, 1, },
	{ 5, KEY_D, 1, }, { 4, KEY_B, 1, }, { 4, KEY_G, 1, }, { 4, KEY_A, 2, }, { 4, KEY_D, 1, },
	{ 4, KEY_G, 6, },
	{ 0xff, 0xff, 0xffff, },
};

void play(int ch, SEQ* seq)
{
	const char* keyname[] = { "c", "c+", "d", "d+", "e", "f", "f+", "g", "g+", "a", "a+", "b", };
	while (seq && !(seq->oct == 0xff && seq->keycode == 0xff && seq->duration == 0xffff)) {
		printf("o%i%s(%i) %i\n", seq->oct, keyname[seq->keycode], freqtable[seq->keycode], seq->duration);
		keyon(ch, seq->oct, freqtable[seq->keycode]);
		::Sleep(BEATTIME * seq->duration);
		keyoff(ch);
		seq++;
	}
}

int main()
{
	FT_STATUS status = FT_OK;
	FT_DEVICE_LIST_INFO_NODE devList = { 0 };

	pInterface = new CFTSPI();

	reset();
	::Sleep(10);


	init825();
	set_tone(tone_data1, sizeof(tone_data1));
	set_ch(2);
	set_volume(2, 120, 64);

	play(2, daisybell);

	delete pInterface;

	return 0;
}

